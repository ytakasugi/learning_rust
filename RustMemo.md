# [Rust の特徴](https://gist.github.com/gushernobindsme/4cec7a02bdaa6f8dd7fe4f13a1974b30)

---

## なぜ Rust なのか？

---

### トップクラスのパフォーマンス

Rust で開発したプログラムの実行速度は、数あるプログラミング言語の中でもトップクラスに位置する。
理由は下記の通り。

- マシンコードへコンパイル
- 静的型付け
- ゼロコスト抽象化
- GC を行わない軽量なランタイム

#### マシンコードへコンパイル

Rust は、コンパイラがプログラムをマシンコード（プロセッサが理解できる機械語）へ変換する。
Java、Ruby、Python ではバイトコード（仮想マシンが理解できるコード）へコンパイルされる。仮想マシンはソフトウェアで実現されているため、マシンコードと比べると速度面で不利になる。

#### 静的型付け

静的型付け言語では、変数および関数の引数や戻り値などすべての値について、その型をコンパイル時に決定する。
動的型付けを行う言語では、プログラムの実行時に実際の値を見て型を判断する。
静的型付け言語では、実行時に値の型チェックをする必要がないため、速度面で有利になる。

#### ゼロコスト抽象化

ゼロコスト抽象化とは、プログラム言語が持つ抽象化の仕組みが実行時のコストなしに動作すること。
Rust はゼロコスト抽象化を中心的な設計原則として扱っている。
抽象化機構を使っても全体的な実行速度の低下やメモリ使用量の増加などを引き起こさないよう、コンパイラとライブラリの設計に細心の注意が払われている。

例えば、Rust ではポリモーフィズムの実現方法に「静的ディスパッチ」を採用している。

- Java を含むほとんどのオブジェクト指向言語では、実行時に値（オブジェクト）の型を調べ、その型に対応するメソッドを呼び出す（動的ディスパッチ）
- Rust はデフォルトでコンパイル時に分かる型によって呼び出すべきメソッドを決める（静的ディスパッチ）

ただし、Rust でもすべてのユースケースで静的ディスパッチが使える訳ではない。

多くの言語ではクロージャはガベージコレクションの対象となるデータ構造で実現されている。
関数の呼び出しも動的ディスパッチに似た方法になる。
そのため、クロージャの作成と実行は通常の関数呼び出しよりも実行時のコストがかかる。

Rust のクロージャは内部的にはポリモーフィズムの仕組みを使って実装されている。
静的ディスパッチが用いられるため、実行時のコストを心配せず使える（通常の関数呼び出しと同じになる）。

#### GC を使わない軽量なランタイム

ガベージコレクション（GC）を行うかどうかもソフトウェアの性能、特に応答性やメモリ使用量に影響する。
Java などで採用されている手法は応答性が悪化したり、全体のメモリ使用量が多くなる傾向がある。

C++、C、Rust は GC を行わないため、プログラムの応答時間やメモリ使用量が予測しやすくなる。
そのため、OS や組み込みシステムなど、リソースが極端に限られている環境にも適している。

### 安全なシステムプログラミング言語

C や C++ は、メモリ内容への柔軟なアクセスが可能で、また軽量かつコンパクトなマシンコードにコンパイルされる。
しかし、軽量であるがゆえに以下のようなバグを仕込んでしまう危険性がある。

- データの転記の際のメモリ領域あふれ
- ポインタによる誤ったメモリ領域へのアクセス
- 初期化前のメモリ領域へのアクセス
- 解放後のメモリ領域へのアクセス
- データへのポインタと関数へのポインタの混同

Java などの言語では、GC を採用したり、言語からポインタの概念をなくすことで解決している。
Rust ではこのような問題をコンパイラによる静的解析によって解決している。

Rust は GC を採用していない。メモリ領域などのリソースの割当と解放は、コンパイラがソースコードを解析し、必要なコードを自動的に挿入することで実現している。
誤ったポインタの使用はコンパイラにより検出されるため、問題のあるプログラムはそもそも実行できない。
この検査機能はマルチスレッドプログラミングにも応用され、データ競合がないこともコンパイル時に保証される。
（C/C++ では開発者の責任とされていた部分を、Rust ではコンパイラが肩代わりしてくれる。）

#### 型安全性

型安全性（type safety）とは、正しく型付けされたプログラムが不正な動作をしないよう言語が定義されていること。
Rust は型安全な言語なので、コンパイル時に問題を検知できる。

#### メモリ安全性

メモリ安全性（memory safety）とは、「プログラムが不正なメモリ操作をしないこと」を言語の処理系が保証すること。
不正なメモリ操作としては、例えば以下のようなものがある。

- データの転記の際のメモリ領域あふれ
- ポインタによる誤ったメモリ領域へのアクセス
- 初期化前のメモリ領域へのアクセス
- 解放後のメモリ領域へのアクセス

#### マルチスレッドプログラミングにおけるデータ競合の回避

複数スレッド間で共有しているデータを同時に読み書きすると、データ競合が発生する。
これが起こると、共有しているデータが予想のつかないものになってしまう。
Rust ではコンパイラの静的解析機能を使い、データ競合の可能性を検出できる。コンパイルに成功したら、そのプログラムにはデータ競合がないことが保証される。

Rust ではスレッド間でデータを受け渡したり共有したりするために、いくつかの方法が用意されている。

- チャネル（channel）
- ロック（lock）
- 配列などの範囲
- イミュータブルな参照

さらに Rust ではあるデータがスレッド間で送受信できるか、または、複数のスレッド間で共有できるかを型レベルで管理する。

- データ競合（data race）：競合によってメモリの内容が壊れる（内容が保証できなくなる）こと
- 競合状態（race condition）：競合によってスレッド間の処理の前後関係が変わったり、複数のスレッドの処理結果が混ざってしまったり、デッドロックでスレッドの実行が先に進まなくなったりすること

#### アンセーフなコードのサポート

Rust ではコンパイラが安全性を確認できないコードであっても書くことができる。
その際は、該当のコードを unsafe キーワードのついたブロックで囲む必要がある。

例えば、以下のような操作では unsafe ブロックが必要となる。

- 生ポインタの参照はずし
- アンセーフな関数の呼び出し
- ミュータブルなスタティック変数へのアクセス
- アンセーフなトレイトの実装

### 生産性を高めるモダンな機能

Rust では、他の言語が持つ便利な機能をいろいろと取り入れている。

- 強力な型推論
- 代数的データ型
- パターンマッチ
- トレイトによるポリモーフィズム

### シングルバイナリ、クロスコンパイル

Rust ではアプリケーションをビルドするとシングルバイナリが生成される。
基本的にはこのバイナリを実行したい環境にコピーするだけでデプロイが完了する。

### 多言語との連携が容易

Rust は FFI（多言語関数インタフェース）を通じて、他の言語と連携できる。
また GC などの複雑なランタイムを持たないため、Python、Ruby、Node.js などからでも Rust の関数を簡単に呼び出せる。

FFI 関連のツールとしては以下のようなものがある。

- bindgen
- Neon
- PyO3
- Ruru
- Ruster

# はじめての Rust プログラム

---

## インストール

---

### ツールチェイン、リンカ、ABI

Rust プログラムをコンパイルしてバイナリを生成するためには、以下のソフトウェアが必要：

- Rust ツールチェイン
- ターゲット環境向けのリンカ

Rust ツールチェインは Rust で書かれたソースコードをコンパイルするのに使われるプログラミングツールの総称。
以下のもので構成されている：

- rustc：Rust コンパイラ
- cargo：Rust のビルドマネージャ兼パッケージマネージャ
- std：Rust の標準ライブラリ

リンカは rustc や他の言語のコンパイラから出力したオブジェクトファイルやライブラリを統合して、ターゲット環境の ABI（Application Binary Interface）に準拠した実行可能ファイルを生成する。

### rustup

rustup は Rust プロジェクトが公式にサポートしているコマンドラインツール。
以下のような機能がある：

- 複数バージョンの Rust ツールチェインのインストールと管理
- クロスコンパイル用ターゲットのインストール
- RLS（Rust Language Server） などの開発支援ツールのインストール

rustup を使用することで、複数の Rust ツールチェインを管理できる。

- stable：安定版
- beta：ベータ版
- nightly：開発版

### インストール

Rust ツールチェインは以下のコマンドでインストールできる。

```
curl https://sh.rustup.rs -sSf | sh
```

Linux 環境の rustc はリンカとして cc コマンドを実行する。
cc の実態は gcc コマンドで、リンカではなく GNU Compiler Collection が提供するコンパイルドライバ。
コンパイルドライバとは、必要に応じて様々な言語のコンパイラやリンカを連続して実行してくれるツールのこと。
gcc がデフォルトで使用する本当のリンカは ld コマンド。

Linux 環境向けのバイナリを作るためには gcc をインストールする必要がある。

```
sudo yum install gcc
```

macOS 環境では clang と BSD 系 Unix 由来の ld を使用する。
どちらも Apple が無償で提供する「コマンドライン・デベロッパ・ツール」に含まれている。

```
cc -v
```

---

## Hello World プログラム

---

`cargo new` することでパッケージを雛形を作ることができる。

- `--bin` オプション：バイナリパッケージが作られる。 `src/main.rs` を持ち、ビルドすると実行可能バイナリファイルができる
- `--lib` オプション：ライブラリパッケージが作られる。 `src/lib.rs` を持ち、ビルドすると他の Rust パッケージから再利用できるライブラリファイルができる

`cargo new` すると `Cargo.toml` というファイルが作られる。
クレートの名前や作者名が書けるほか、依存クレートの情報を書くことで crates.io や GitHub などのリポジトリから必要なクレートをダウンロードすることができる。

パッケージのビルド：

```
cargo build
```

バイナリの実行：

```
cargo run
```

ビルド済みバイナリの削除：

```
cargo clean
```

---

## ツールチェインの補足情報

---

### プラットフォーム、サポート・ティア

Rust プロジェクトではプラットフォームごとのサポートのレベルを以下の通り分類している。

- Tier1
  - 公式のバイナリインストーラが提供される
  - 開発時に自動テストが実行される
  - 自動テストにパスしない変更はそれが解決されるまで master ブランチにマージされない
  - ツールの使用方法などが記載されたドキュメントが用意されている
- Tier2
  - 公式のバイナリインストーラが提供される
  - 自動ビルドが行われているが、テストが実行されているとは限らない
  - ビルドできない変更はそれが解決されるまで master ブランチにマージされない
- Tier3
  - 基本的に保証しない

### リリースサイクルとリリースチャネル

Rust ではトレインモデルと呼ばれる高速なリリースサイクルを採用している。
リリースを管理するためにリリースチャネルという概念がある。

- Nightly チャネル
  - 開発中の最新バージョンが毎晩リリースされる
  - 実験的な機能も含まれており `feature` アトリビュートを追加することで利用できる
- Beta チャネル
  - 6 週間ごとに、その時点での最新のソースコードから beta リリースが作られる
  - beta リリースが作られてから 6 週間経つと stable リリースに昇格する
  - フィーチャーゲートされている機能は利用できない
- Stable チャネル
  - 6 週間の beta 期間を経た後にリリースされる安定版
  - マイナーバージョンに相当する数字が 1 つ上がる
    - メジャーバージョンが同じリリースの間では後方互換性が保証される
    - メジャーバージョンが上がるリリースは今のところ予定されていない
  - フィーチャーゲートされている機能は利用できない

### エディション

Rust 1.31.0 以降からは 2 つのエディションに対応している。

- 2015 エディション：Rust 1.0.0 と後方互換性が保たれる仕様
- 2018 エディション：新しい予約後

同じエディションの中であれば、 Rust のリリース間で後方互換性が保たれる。
どのエディションを使うかは `Cargo.toml` ファイル内の edtion で選択できる（クレート単位で選択可能）。

```
[package]
edition = "2018"
```

`cargo fix` コマンドを使うことで 2015 仕様のコードを 2018 仕様に変換できる。

- https://doc.rust-jp.rs/edition-guide

### rustup のその他の機能

インストール済みツールチェインの表示：

```
rustup show
```

追加のツールチェインのインストール：

```
rustup install ${ツールチェイン名}
```

ツールチェインの最新化：

```
rustup update
```

ツールチェインの切り替え：

```
rustup default ${ツールチェイン名}
```

### Cargo の主なコマンド

Cargo のコマンド一覧は以下の方法で表示できる。

```
# 基本的なコマンドを表示する
cargo -h

# すべてのコマンドを表示する
cargo --list
```

`cargo install` すると、crates.io から便利なサブコマンドをインストールできる。
代表的なカスタムサブコマンドは Cargo の Wiki ページに掲載されている。

- https://github.com/rust-lang/cargo/wiki/Third-party-cargo-subcommands

---

# クイックツアー

---

## 第 1 段階：初歩的な実装

---

### 識別子の命名規則について

Rust では関数、変数、定数などの識別子にはスネークケースを使う。
関数やローカル変数の識別子は小文字で統一する。
定数やグローバル変数では大文字で統一する。

ユーザが定義した型やジェネリクスの型パラメータの識別子にはキャメルケースを使う。

違反するとコンパイラが警告を出す。アトリビュートを指定することで、警告を無視することもできる。

- `#[allow(non_snake_case)]`
- `#[allow(non_upper_case_globals)]`
- `#[allow(non_camel_case_types)]`

### コーディング規約について

「Rust Style Gude」が用意されているので、それに従うのが良い。
（rustfmt というツールを使うことで遵守できるので、覚える必要なし。）

- https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md

「Rust API Guide」という API デザイン上の推奨事項をまとめた文書もある。

- https://rust-lang-nursery.github.io/api-guidelines

---

# プリミティブ型

---

## 型の分類

- プリミティブ型：言語組み込みの型
  - スカラ型：単純な型。真理値、整数、浮動小数点、文字（char）など
  - 複合型：アクセスできる内部構造を持つ型。タプル、配列、スライス、文字列スライスなど
- ユーザ定義型：ベクタ、文字列、ユーザが定義した構造体など

## スカラ型

### ユニット

空を表す型。値をただ 1 つだけ持つ。
その値は空のタプル `()` で「ユニット値」と呼ぶ。

例えば値を返さない関数の戻り値はユニット型となる（void みたいなもんかな）。

### 真理値

bool。true または false を持つ値。

### 固定精度の整数

0、100、-999 など固定長のビット幅で表現される整数値。
「ビット幅指定の整数型」と「アドレス幅の整数型」がある。

- ビット幅指定の整数型
  - ビット幅を指定した整数。CPU アーキテクチャなどの環境に依存しない
  - 符号付きの整数：i8、i16、i32、i64、i128
  - 符号なしの整数：u8、u16、u32、u64、u128
- アドレス幅の整数型
  - ターゲットとする CPU のメモリアドレスのビット幅によってサイズが決まる整数
  - 符号付きの整数：isize
  - 符号なしの整数：usize

整数リテラスはデフォルトで i32 型として解釈される。

また、C 言語などに見られる以下の演算子は Rust にはない。

- 単項のインクリメント、デクリメント（++、-- など）
- 三項演算子

四則演算やシフト演算などはリリースモードでは桁あふれが検出されない。
桁あふれが起こりうるときは以下の演算の利用を検討すること。

- 検査付き演算：桁あふれが発生しなければ `Some(値)` を返、発生したら `None` を返す。`checked_`
- 飽和演算：最大値を上回った場合は最大値を、最小値を下回った場合は最小値を返す。`saturating_`
- ラッピング演算：桁あふれを無視する（値の範囲を周回しているように振舞う）。`wrapping_`
- 桁あふれ演算：桁あふれを無視するが、演算結果と一緒に桁あふれの発生有無を bool 値で返す。`overflowing_`

### 固定精度の浮動小数点

固定長のビット幅で表現される小数の値。
f32 と f64 型の二種類があり、IEEE 754形式の単精度と倍精度の浮動小数点に対応している。

小数リテラルはデフォルトで f64 型になる。

### 文字

文字型は値として Unicode の 1 文字（正確には 1 つの Unicode スカラ値）を持つ。
char リテラルはシングルクォート `'` で作ることができる。

Unicode スカラ値はコードポイントのうち、サロゲートペアで使われるコードを除いたものを指す。
（具体的には `U+0` から `U+D7FF` までと `U+E000` から `U+10FFFF` までの値を取る。）

Unicode では表示上の一文字が複数のコードポイントで構成されることもある。
char 型の値は 1 つの Unicode スカラ値を表すため、 👨‍👩‍👦 のような文字で char リテラルを作ろうとするとコンパイルエラーになる。

### 参照

参照型はメモリ安全なポインタ。
参照はポインタで指したい値に `&` や `&mut` をつけることで作成できる。

`&T` はイミュータブルな参照で、参照先の値の読み出しだけが可能。
`&mut T` はミュータブルな参照で、参照先の値の読み出しと書き出しが可能。
ポインタが指す値を取り出したり、ポインタが指す値を変更したりするときには、ポインタの先頭に `*` をつける。これを「参照外し」と呼ぶ。

### 生ポインタ

生ポインタ型はメモリ安全ではないポインタ。
不変の生ポインタは `*const T` 型、可変の生ポインタは `*mut T` 型となる。

生ポインタは、ポインタを他の言語との間で受け渡したり、所有権システムの管理から外したい場合に使う。
コンパイラが安全を保証できない操作のため `unsafe` ブロック内に書く必要がある。

### 関数ポインタ

関数を指すポインタ。

こういう関数を、

```
fn double(n: i32) -> i32 {
    n + n
}
```

こんな風に呼び出せる。

```
let mut f: fn(i32) -> i32 = double;
assert_eq!(f(-42), -84);
```

## プリミティブな複合型

### タプル

`(88, true)` や `(0.0, -1.0, 1.0)` のように、カンマで区切った要素の組を持つ型。

タプルの要素の数を「要素数」または「アリティ」と呼ぶ。
要素数はコンパイル時に決まり、実行時には変更できない。

タプルの要素を取り出したり変更したりする際は、フィールド名かパターンマッチを使う。

フィールド名を使うやり方：

```
let t1 = (88, true);

assert_eq!(t1.0, 88);
assert_eq!(t1.1, true);
```

パターンマッチを使うやり方：

```
let (n1, b1) = (88, true);
assert_eq!(n1, 88);
assert_eq!(b1, true);
```

### 配列

```
let a1 = [false, true, false];
let a2 = [0.0, -1.0. 1.0. 0.5];
```

配列の長さはコンパイル時に決まり、実行時には変えられない。
（実行時に長さを決めたい、要素を追加・削除したい場合はベクタ型を使うと良い。）

配列の要素を取り出したり書き換えたりする際は、インデックスかイテレータを使う。

インデックス：

```
# 直接 index を指定する
let array1 = ['H', 'e', 'l', 'l', 'o'];
assert_eq!(array1[1], 'e');

# get() を使って安全に取得する
let array3 = [0, 1];
assert_eq!(array3.get(1), Some(&1));
assert_eq!(array3.get(2), None);
```

イテレータ：

```
let array4 = ['a'; 50];

for ch in array4.iter() {
    print!("{},", *ch);
}
```

Rust では配列に対してスライスのメソッドを呼び出そうとすると、その配列をスライスへと暗黙的に型強制（type coerecion）する仕組みになっている。

### スライス

スライス型は配列要素の範囲に効率よくアクセスするためのビュー。

スライスには、不変・可変の参照か Box というポインタの一種を経由してアクセスする。
型は `&[bool]` 、`&mut [bool]` 、 `Box<[bool]>` のように表記する。
（イミュータブルなスライスも、ミュータブルなスライスも作れる。）

```
let a1 = ['a', 'b', 'c', 'd'];

print_info("&a1[..]",   &a1[..]);
print_info("&a1",       &a1);
print_info("&a1[1..3]", &a1[1..3]);
```

スライスには配列を操作する上で便利なメソッドが用意されている。

```
let a3 = ["zero", "one", "two", "three", "four"];
let s3 = &a3[1..4];
assert!(!s3.is_empty());
assert_eq!(s3.len(), 3);
assert_eq!(s3.first(). Some(&"one"));

assert!(s3.contains(&"two"));
assert!(s3.starts_with(&["one", "two"]));
assert!(s3.ends_with(&["two", "three"]));
```

可変のスライスだと `sort()` とか `split_at_mut()` とか `reverse()` とかいろいろできる。

### 文字列スライス

str 型は Unicode の文字で構成された文字列。
ほとんどの場合、str にはスライスを通じてアクセスするため、文字列スライス型と呼ばれる。
`&str` か `&mut str` と表記する。

str リテラルはダブルクオート `"` で作る。型は `&'static str` 。

str には文字列を扱うのに便利なメソッドが用意されている。

```
let fruits = "あかりんご、あおりんご\nラズベリー、ブラックベリー";

let mut lines = fruits.lines();
let apple_line = lines.next();
assert_eq!(apple_line, Some("あかりんご、あおりんご"));
assert_eq!(lines.next(), Some("ラズベリー、ブラックベリー"));
assert_eq!(lines.next(), None);
```

ほか、`starts_with()` 、 `contains()` 、 `find()` 、 `split()` 、 `trim` などなど。

str には長さを取得するための `len()` メソッドがある。
が、このメソッドが返す値は UTF-8 のバイト数になるため注意。

`&str` は不変スライス経由のアクセスのため、文字の追加・変更・削除はできない。
`&mut str` は変更可能だが、要素の追加・削除はできない等の制限があるため、用途が限られている。

---

# ユーザ定義型

---

## スタック領域とヒープ領域

スタック領域はスレッドごとに用意されるメモリ領域。
関数の引数やローカル変数など、関数内やスレッド内だけで使われるデータが格納される。
関数から抜けたり、スレッドが終了すると、スタックの内容は破棄される。

ヒープ領域はプログラム内で共有されるデータを格納するメモリ領域。
必要な時に確保と開放ができる。

スタック領域は複雑な仕組みを使わずに管理できるため、確保と開放が高速に行える。
ヒープ領域は複雑で、アロケータと呼ばれるライブラリを通して確保・開放するため、スタック領域の確保・開放と比べると遅くなる。

スタック領域は高速な反面、サイズがあまり大きくない（スタックにしまいきれなくなるとスタックオーバーフローが発生し、スレッドの実行が打ち切られる）。
ヒープ領域はサイズが非常に大きく、大量の値を格納できる。

| 領域         | 確保のタイミング | 開放のタイミング | 確保・開放の速さ       | 領域の大きさ |
| ------------ | ---------------- | ---------------- | ---------------------- | ------------ |
| スタック領域 | 関数の呼び出し時 | 関数から戻る時   | 速い                   | 小さい       |
| ヒープ領域   | 任意の時点       | 任意の時点       | スタックと比べると遅い | 大きい       |

スタック領域の方が確保と開放が速いことから、Rust はデフォルトで値をスタック領域に置く。
一方、以下のような値はデータの一部をヒープ領域に置く。

- Box ポインタ
- `Vec<T>` や `HashMap<K, V>` のような要素数が可変のコレクション型の要素
- String や OSString のような文字の追加や削除が可能な文字列型の要素

Rust ではコンパイル時にサイズが決定できないデータをスタック領域に置けない。
そういうデータを持つ型はヒープ領域を使用する。

## 標準ライブラリの主な型

### Box（ `std::boxed::Box<T>` ）

`Box<T>` はメモリ安全なポインタで、以下の特徴を持つ。

- 対象のデータをヒープ領域に置く
- ポインタでありながら、対象のデータを所有する

```
let t1 = (3, "birds".to_string());
let mut b1 = Box::new(t1);
(*b1).0 += 1;
assert_eq!(*b1, (4, "birds".to_string()));
```

Box ポインタは以下のような場面で使われる。

- コンパイル時にデータサイズが決まらない型を扱うとき（たとえば再起的なデータ構造を実現したいとき）
- 大きなデータをコピーすることなく、その所有権を他者へ移動したいとき
- トレイトオブジェクトを作成したいとき

### ベクタ（ `std::vec::Vec<T>` ）

ベクタは配列を表現する型。

- 要素の追加や削除ができる
- ヒープ領域にデータが置かれる（配列の場合はスタック領域）

```
let mut v6 = vec!['a', 'b', 'c'];
v6.push('d');
v6.push('e');
assert_eq!(v6, ['a', 'b', 'c', 'd', 'e']);

assert_eq!(v6.pop(), Some('e'));
v6.insert(1, 'f');
assert_eq!(v6.remove(2), 'b');
assert_eq!(v6, ['a', 'f', 'c', 'd']);

let mut v7 = vec!['g', 'h'];
v6.append(&mut v7);
assert_eq!(v6, ['a', 'f', 'c', 'd', 'g', 'h']);
assert_eq!(v7, []);

let a8 = ['i', 'j'];
v6.extend_from_slice(&a8);
assert_eq!(v6, ['a', 'f', 'c', 'd', 'g', 'h', 'i', 'j']);
assert_eq!(v8, ['i', 'j']);
```

空のベクタを作る時は `new()` メソッドを使う。
事前に大まかな要素数がわかっている場合は `with_capacity(要素数)` メソッドを使うと良い。
（ベクタに要素数を追加していく際のメモリ再割り当てのオーバヘッドを削減できる。）

### その他のコレクション型

`std::collections` モジュールには、他にも以下のようなコレクション型が定義されている。

- マップ：HashMap、BtreeMap
- セット：HashSet、BtreeSet
- キュー：VecDeque、BinaryHeap
- リスト：LinkedList

### String（ `std::string::String` ）

String の作り方：

```
let mut s1 = "ラズベリー".to_string();
let mut s2 = String::from("ブラックベリー");
```

数値型などの値から String を作る場合：

```
let i = 42;
assert_eq!(i.to_string(). "42");

let f = 4.3 + 0.1;
asset_eq!(format!("{:.2}", f), "4.40");
```

文字列から数値型の値を作る場合：

```
let s1 = "42";
assert_eq!(s1.parse::<i32>(), Ok(42));
```

String と str の違いは以下の通り。

| 型     | 役割                      | 実データを格納するメモリ領域 | 文字の追加・削除 | 実データを所有する？ |
| ------ | ------------------------- | ---------------------------- | ---------------- | -------------------- |
| String | サイズ可変の UTF-8 文字列 | ヒープ                       | 可               | 所有する             |
| str    | サイズ固定の UTF-8 文字列 | 参照先による                 | 不可             | 所有しない           |

関数の引数として文字列をとるとき、文字列が不変で構わないなら作成コストの低い &str にすべし。
可変でないと困るなら &mut String、所有権も必要なら String とすべし。

他にも以下のような文字列型が用意されている。

- CString と CStr：C 言語で用いられる null 終端文字列
- OsString と OsStr：OS ネイティブの文字列
- PathBuf と Path：ファイルシステムのパスを表現する文字列

### 範囲（ `std::ops::Range` ）

`start..end` 、 `start..=end` 、 `start..` 、`..end` などの形で範囲数列の作成やスライスの範囲指定ができる。
プリミティブ型ではなく、ユーザ定義型で実現されている。

### オプション（ `std::option::Option<T>` ）

オプション型は、値があるかどうかがわからないことを表す型。
列挙型として定義されており、 `Some(T)` と `None` の２つのバリアントを持つ。
オプション型の値が存在するかを調べるには、 match 式や let 式を使う。

```
let mut o1 = Some(10);
match o1 {
    Some(s) => assert_eq!(s, 10),
    None => unreachable!(),
}

o1 = Some(20);
if let Some(s) = o1 {
    assert_eq!(s, 20);
}
```

オプション型にはアンラップに便利なメソッドがいくつか定義されている。

```
let mut o2 = Some(String::from("Hello"));
assert_eq!(o2.unwrap(), "Hello");

o2 = None;
assert_eq!(o2.unwrap_or_else(|| String::from("o2 is none")), "o2 is none");
```

`unwrap()` は None のとき panic するので、できるだけ使わない方が良い。
`unwrap_or_else()` なら None のときに代わりの値を返せるので安心。

Some で包まれた中の値を加工したい場合は `map()` や `and_then()` を使う。

```
let mut o3 = Some(25);
assert_eq!(o3.map(|n| n * 10), Some(250));

o3 = None;
assert_eq!(o3.map(|n| n * 10), None);

o3 = Some(10);
assert_eq!(
    o3.map(|n| n * 10)
        .and_then(|n| if n >= 200 { Some(n) } else { None }),
    None
);
```

オプションを扱う場合、 `?` 演算子が便利。
値が Some ならアンラップし、None ならそのまま None が返される。

```
fn add_elems(s: &[i32]) -> Option<i32> {
    let s0 = s.get(0)?
    let s3 = s.get(3)?
    Some(s0 + s3)
}

assert_eq!(add_elems(&[3, 7, 31, 127]), Some(3 + 127));
assert_eq!(add_elems(&[7, 11]), None);
```

### リザルト（ `std::result::Result<T, E>` ）

リザルト型は、処理の結果がエラーになる可能性を暗示する型。
列挙型として定義されており、 `Ok(T)` と `Err(E)` の 2 つのバリアントを持つ。

```
assert_eq!("10".parse::<i32>, Ok(10));

let res0 = "a".parse::<i32>();
assert!(res0.is_err());
```

オプション値と同様、複数のリザルト値を扱う時は `?` 演算子が便利。

リザルト型にも `map()` 、 `and_then()` 、 `or_else()` などが定義されている。
`map_err()` を使うとエラーを書き換えられる。

標準ライブラリでは `std::num::ParseIntError` や `std::io::Error` など、さまざまなエラー型が定義されている。
ライブラリを開発して誰かに使ってもらうなら、これらのエラーが起こったときにそのまま返さない方が良い。
独自のエラー型を定義して、それに変換してから返す方が利用者にとって使いやすくなることが多い。

Option と Result の相互変換も可能。

- `Option<T>` の `ok_or_else()` メソッド：`Option<T>` から `Result<T, E>` へ変換
- `Result<T, E>` の `ok()` メソッド：`Result<T, E>` から `Option<T>` へ変換

## 新しい型の定義と型エイリアス

型エイリアスは型に付けられる別名のこと。 `type` キーワードで定義できる。
型のネストが深くなった時に使うと便利。

```
use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

pub type SharedMap<K, V> = Rc<RefCell<HashMap<K, V>>>
```

### 構造体

構造体は複数の関連する値を 1 つにまとめたデータ構造。
構造体には 3 つの種類がある。

- 名前付きフィールド構造体
- タプル構造体
- ユニット構造体

#### 名前付きフィールド構造体

定義：

```
struct Polygon {
    vertexes: Vec<(i32, i32)>,
    stroke_width: u8,
    fill: (u8, u8, u8),
}
```

初期化：

```
let triangle = Polygon {
    vertexes: vec![(0, 0), (3, 0), (2, 2)],
    fill: (255, 255, 255),
    stroke_width: 1,
};
```

フィールドへのアクセス：

```
assert_eq!(triangle.vertexes[0], (0, 0));
assert_eq!(triangle.fill, (255, 255, 255));
assert_eq!(triangle. stroke_width, 1);
```

#### タプル構造体

タプルのような構造体も作れる。
この場合、フィールド名は 0 から始まる連番となる。

```
struct Triangle(Vertex, Vertex, Vertex);
struct Vertex(i32, i32);
```

タプル構造体の便利な使い方の 1 つに newtype というデザインパターンがある。
型エイリアスの代わりにフィールドが 1 つのタプル構造体を定義することで、コンパイラの型チェックを強化するテクニック。

- https://doc.rust-lang.org/1.0.0/style/features/types/newtype.html

#### ユニット構造体

フィールドを持たない構造体も定義できる。

```
struct UnitqueValue;
```

### 列挙型（enum）

列挙型は異なる種類の型を 1 つにまとめた型を定義するためのもの。

よくある enum：

```
enum Weekday {
    Monday, Tuesday, Wednesday, Thursday, Friday,
}
```

データを持たない列挙型では個々のバリアントに isize 型の整数値を割り当てられる。
（定義時に整数値を与えなかった場合、0 始まりで値が設定される。）
as で isize 型にキャストすると割り当てた値が得られる。

```
enum Month {
    January = 1, February = 2, March = 3, (中略), Decenber = 12,
}

assert_eq!(3, Month::March as isize);
```

バリアントには構造体と同じ文法でフィールドを持たせることができる。

```
type UserName = String;

#[derive(Debug)]
enum Task {
    Open,
    AssignedTo(UserName),
    Working {
        assignee: UserName,
        remaining_hours: u16,
    },
    Done,
}
```

### 構造体と列挙型のより詳しい情報

構造体や列挙型の可視性はデフォルトで非公開。
モジュール外からアクセスできるようにするには pub キーワードを追加する。

構造体や列挙型のフィールドに参照を持たせることもできる。
その際はライフタイム指定子（ `'a`）が必要。

また、構造体や列挙型もジェネリクスにできる。

## 型変換

### 型キャスト

`as` 型を使った明示的な型変換。

```
let i1 = 42;
let f1 = i1 as f64 / 2.5;

let c1 = 'a';
assert_eq!(97, v1 as u32);
```

as はスカラ型同士の型変換だけをサポートしている。
（タプルや配列のような複合型の変換には使えない。）

### Transmute（ `std::mem::transmute` ）

明示的かつアンセーフな型変換の仕組み。
メモリ上の表現（ビット列）のサイズさえ同じなら、どんな型同士でも変換できる。

```
let p1 = Box::new(10);

let p2 = p1 as *mut i32;
let p3 : *mut i32 = unsafe { std::mem::transmute(p1) };
```

値の型に関する情報を変更するが、値自体の変換はしない。
そのため、変換後の値が無意味なものになることもある（なにに使うんだ？）。

### 型強制

型強制はコンパイラが必要に応じて行う暗黙的な型変換。

---

# 基本構文

---

Rust ではコンパイルとリンクの単位をクレートと呼ぶ。

クレートの中はモジュールという単位で階層化されていて、クレートの最上位には匿名のモジュールがある、という建前になっている。
Cargo はパッケージの src ディレクトリの中に main.rs ファイルがあると、そのパッケージをバイナリパッケージと判断し、実行可能ファイルを生成しようとする。
実行可能ファイルを生成するには、 main.rs ファイルに main() 関数が必要。

## コメント

行コメント `//` とブロックコメント `/* */` が使える。
`///` で始まるコメントはドキュメンテーションコメントとして扱われる。

## use 宣言

use 宣言は、他の名前空間にあるプログラム要素の別名を作る。
use 宣言を使うことで、他の名前空間にあるプログラム要素への参照を短く書けるようになる。

## 関数

```
fn 名前([引数リスト]) [-> 戻り値の型] {
    関数本体
}
```

### 式と文

Rust では、文とは `()` を返すプログラム要素を指す。文の末尾には `;` をつける。
式とは、 `()` 以外の値を返すプログラム要素を指す（文以外のものは式と考えて OK ）。

### 関数の実行

Rust は式指向言語であり、プログラム要素は基本的に式（値を返すもの）になる。
そのため、多くの場合、関数では関数の本体の式を実行した結果の値がそのまま関数の戻り値となる。明示的に return 文を書く必要はない。
（関数の本体の最後の return 文は省略する方が Rust らしい、とされている。）

戻り値として `()` を返すのではなく、本当に値を返さない関数もある。
発散する関数は、そもそも呼び出し元に制御を返さない。

```
fn end_function()  -> ! {
    std::process::exit(0);
}
```

### メソッド

メソッドとは、構造体などの中に定義された関数の一種。
構造体以外にも、列挙型やトレイトなどの中にもメソッドを定義できる。

```
struct Circle {
    radius: u32,
}

impl Circle {
    fn diameter(&self) -> u32 {
        self.radius * 2
    }
}
```

メソッドの実行には `.` を使う。
`構造体などのインスタンス.メソッド(引数)` でメソッドを実行できる。

```
fn main() {
    let circle1 = Circle { radius: 10};
    println!("Circle1's diameter: {}", circle1.diameter());
}
```

### 関連関数

構造体など、データ型そのものに関数を関連づけることもできる。
構造体などそのものに関連づけられた関数を関連関数と呼ぶ（static method みたいなやつかな）。

```
struct Circle {
    radius: u32,
}

impl Circle {
    fn diameter(&self) -> u32 {
        self.radius * 2
    }

    fn small_circle() -> Circle {
        Circle { radius: 1 }
    }
}
```

`構造体など::関連関数(引数)` で関連関数を実行できる。

```
fn main() {
    let circle1 = Circle::small_circle();
    println!("Circle1's diameter: {}", circle1.diameter());
}
```

## 束縛とミュータビリティ

変数と値を結びつけることを Rust では「変数を値に束縛する」と表現する。

```
let パターン[: 型] [= 初期化式];
```

通常の let 文で変数を宣言するとイミュータブルとなる。
`mut` キーワードを付与することで変数をミュータブルにできる。

```
let mut パターン[: 型] [= 初期化式];
```

### スコープ

変数の有効範囲のことをスコープと呼ぶ。
Rust では変数は導入されたブロックの中でだけ有効。

### シャドウイング

変数は同じ名前で複数作ることができる。

```
let x = 10;
let x = 20;
let x = "String";
```

同じ名前の変数を後から導入した場合、実際にその名前で使用できる変数は最後に導入した変数となる。
新しく導入した変数で前に導入した変数を隠してしまうことをシャドウイングと呼ぶ。
（全く別の新しい変数を導入するものなので、ミュータビリティとはまた別の話。）

### 定数とスタティック変数

定数を定義するには、 const 文を使う。
const で定義された定数はコンパイル時に一度だけ計算される。

```
cost 名前: 型 = 定数式;
```

スタティック変数を定義するには、 static 文を使う。
スタティック変数は値が埋め込まれることはなく、使われるたびに参照される。

```
static [mut] 名前: 型 = 定数式;
```

ミュータブルなスタティック変数も作れるが、他のスレッドで値が変更される可能性があるため、unsafe ブロックの中でしか読み書きできない。

## 分岐

### if 文

```
if 条件式 {
    true 節
} else {
    false 節
}
```

### match 式とパターン

```
match 検査される値 {
    パターン1 => 式1,
    パターン2 => 式2,
    パターン3 => 式3,
    ...
}
```

パターンマッチにおける優先順位は、上に書かれたものが優位となる。
（なので、ワイルドカード `_` は最後に指定すること。）

match 式では「どのパターンにもマッチしない」という結果は認められない。
とりうるすべての値を網羅できていない場合、コンパイルエラーとなる。

列挙型の場合、パターンを使ってバリアントに関連づけられた値を取り出すことができる。

```
let unknown = Some("Apple");

let string = match unknown {
    Some(something) => String::from("Hi, ") + something,
    None => String::from("Nothing"),
}

println!("{}", string);
```

複合的な型の値からその中の値を取り出すことを分配束縛と呼ぶ。
パターンを使うと、列挙型以外にも構造体、タプル、参照などに対して分配束縛を行うことができる。

パターンを連結するには `|` を使う。
パターンとして範囲を指定するには `...` を使う。

パターンには条件（ガード）をつけることもできる。

```
let string = Some("This is a very long string");

let message = match string {
    Some(s) if s.len() >= 10 => "Long string",
    Some(_) => "String",
    None => "Nothing",
}

println!("{}", message);
```

### if let 式

if let 式ではパターンを 1 つだけ書くことができ、パターンマッチが成功した場合と失敗した場合とでプログラムを分岐させることができる。

```
if let パターン = 変数 {
    true 節
} else {
    false 節
}
```

## 繰り返し

### loop 式

```
loop {
    ループ本体
}
```

loop 式から抜けるためには、 break 式を使う。
loop 式は式なので、値を返す（break 式の後ろにおいた値が返される）。
cotinue 式を使うと loop 式のループの先頭に戻ることができる。

### while 式

```
while 条件式 {
    ループ本体
}
```

### while let 式

if let 式の while バージョン。
パターンマッチに成功した場合はループの本体を実行し、失敗した場合はループを抜ける。

```
while let パターン = 変数 {
    ループ本体
}
```

### for 式

```
for 要素の名前 in イテレータ {
    ループ本体
}
```

## クロージャ

関数の定義の外にある変数を捕捉する関数をクロージャと呼ぶ。
Rust におけるクロージャは無名関数であり、関数ポインタ型の値と同じように、変数に束縛したり、関数の引数に指定したりすることができる。

```
| 引数リスト | {
    クロージャ本体
}
```

クロージャの引数リストでは推論可能な限り、型を明示する必要はない。

```
let one = 1;
let plus_one = |x| {
    x + one
};

println!("10 + 1 = {}", plus_one(10));
```

クロージャに変数の値をコピーするには move キーワードを使う。
move キーワードを使うと、変数の所有権がクロージャに移転するが、整数など Copy トレイトを持つ型変数については変数の値がクロージャにコピーされる。

```
let mut one = 1;
let plus_one = move |x| {
    x + one
};

one += 1;
println!("10 + 1 = {}", plus_one(10));
```

## アトリビュート

アトリビュートは、アイテム宣言にメタデータをつけるためのもの。

アイテム宣言の前に書く場合：

```
#[test]
fn test1() {
    // 処理内容
}
```

アイテム宣言の中に書く場合：

```
fn test2() {
    #![test]
    // 処理内容
}
```

同じクレートの中の別のモジュールで定義されたマクロを読み込むには、 macro_use アトリビュートを mod キーワードの前につける。

```
#[macro_use] mod macros;

use log::{debug, error};
```

cfg アトリビュートを使うと、条件によってコンパイルするかどうかを決めることができる。

```
#[cfg(unix)]
fn something_for_unix() {
    // 処理内容
}
```

derive アトリビュートを使うと、自動導出というコードの自動生成ができる。
（構造体や列挙型に対してトレイトを自動的に実装してもらえる。）

```
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let some_point = Point {x: 10, y: 20, z: 0};
println!("Debug: {:?}", some_point);
```

allow アトリビュートと deny アトリビュートで Lint の制御ができる。

```
#[allow(unused_imports)]

# [deny(dead_code)]
```

## モジュールとアイテムの可視性

プログラムを複数のモジュールに分割するには、 mod キーワードを使う。

```
mod server {
    pub fn echo() {
        println!("Server");
    }
}

mod client {
    pub fn echo() {
        println!("Client");
    }
}
```

呼び出す時はこう。

```
fn main() {
    server::echo();
    client::echo();
}
```

モジュールの中のアイテムの可視性はデフォルトで private 。
モジュールの外側からアクセスさせたい場合は pub キーワードをつける。
pub キーワードにオプションをつけると、一部の場所に対してだけパブリックなアイテムも作れる。

```
mod server {
    pub(crate) fn echo() {
        println!("Server");
    }
}

mod client {
    pub(in app::network) fn echo() {
        println!("Client");
    }
}
```

モジュールの中のアイテムを指定するときに使う名前空間は、原則として相対指定。
以下のケースは例外的に相対指定。

- 外部のクレートの中のモジュールを指定するとき
- crate を使うとき

モジュールは別のファイルに切り出すことができる。
ディレクトリを使って階層を表現することもできる。
Rust コンパイラにコンパイルの対象として認識してもらうためには、 mod キーワードを使う。

```
pub fn ping(){
    println!("Ping");
}
mod network;

fn main() {
    network::ping();
}
```

---

# 所有権システム

---

## 所有権システムの利点

- ガベージコレクタが不要になる。プログラムのランタイムが軽量化され、応答時間やメモリ使用量が予測しやすくなる
- メモリ安全性がコンパイル時に保証される
- メモリだけでなく、ファイルやロックなどのリソースが使い終わった時点で自動解放できる

### ガベージコレクタが不要になる

GC があると開発者がメモリ管理のためのコードを書かなくて済むため、メモリ管理にまつわる厄介なバグを防げる。
一方で、 GC は実行時の性能に少なからず影響を与える。

例えば Java HotSpot VM では、

- メモリの空きが少なくなってきてからガベージの探索を始めるため、全体的なメモリの使用量が増える傾向にある
- GC の実行中はプログラムの処理速度が目に見えて低下したり、少しの間、応答がなくなったりする

Rust ではコンパイル時の解析により個々のメモリ領域が不要になるタイミングが決定され、それらを解放するコードがコンパイラによって自動的に挿入される。
実行時にガベージの探索や参照カウントの増減を行わないため、余分な負荷がかからず、プログラムの応答時間やメモリ使用量が予測しやすくなる。
（プログラムのランタイムも極めてシンプル。）

### メモリ安全性がコンパイル時に保証される

Rust の所有権システムにより以下のことが保証される。

- メモリの二重解放による未定義動作を起こさない
- 不正なポインタ（ダングリングポインタ）を作らない

値が Sync や Send トレイトを実装しているか確認したり、可変の参照の使われ方を追跡することで、マルチスレッドプログラムにおいてデータ競合が起こらないこともコンパイル時に保証する。

- ダングリングポインタ
  - 解放済みの領域など無効なメモリを指すポインタのこと
  - 参照外しすると未定義動作を引き起こす
- 未定義動作
  - 言語仕様で定義されていない振る舞いのこと
  - プラットフォームやメモリの状態により発生する現象が変わる
  - 未定義動作はプログラムのクラッシュや脆弱性につながるため避けるべし

## 所有権システムの概要

### 所有権（ownership）

- 所有権はある値を所有できる権利のこと
- 変数は値の所有者になれる。値自身の他の値の所有者になれる
- 値には所有権が 1 つだけある（つまり、値の所有権はある時点でただ 1 人だけ存在する）
- 所有者は値を指す不変・可変の参照を作ることで、他者に値を貸し出せる
- 所有者は所有権を他者に譲渡できる（所有権を渡すと、元の所有者は所有権を失う）
- 所有者がスコープを抜ける時に値のライフタイムが尽きる。そのタイミングで値が破棄され、使用していたリソースが解放される

### ムーブセマンティクスとコピーセマンティクス

- ある値から別の変数へ値を代入するとき、値の型によってプログラムの意味が変わる
  - セマンティクス = プログラムの意味
- ムーブセマンティクスでは、代入元の変数から代入先の変数へ所有権が移動（ムーブ）する
- コピーセマンティクスでは、値が複製（コピー）されたとみなし、所有権は移動しない

### 借用（borrow）

- 値を指す参照を作ると、所有権の観点からは値を「借用」していることになる
- 借用には不変の借用と可変の借用がある

### ライフタイム（lifetime）

- ライフタイムは「生存期間」の意味
- 値のライフタイムと参照のライフタイムの二種類がある
- 値のライフタイム（≒値のスコープ）は、値が構築されてから破棄されるまでの期間を指す
- 参照のライフタイムは、値への参照が使用される期間を指す

### 借用規則

- 不変・可変を問わず、参照のライフタイムが値のスコープよりも短いこと
- 値が共有されている間は値の変更を許さない（つまり、ある値について以下のいずれかの状態のみを許容する）
  - 任意の数の不変の参照 `&T` を持つ
  - ただ 1 つの可変の参照 `&mut T` を持つ

## 値のスコープ

構造体や列挙型ではデストラクタ（値が破棄される直前に処理を挟むための関数）を定義できる。
デストラクタは Drop トレイト（ `std::ops::Drop` ）を通じて実装することができる。

```
use std::ops::Drop;

impl Drop for Parent {
    fn drop(&mut self) {
        println!("Dropping {:?}", self);
    }
}
```

同じブロック内では、後から導入された変数が先にスコープを抜ける。

## ムーブセマンティクス

所有権を譲渡することを「所有権をムーブする」と呼ぶ。

```
let mut p1 = Parent(1, Child(11), Child(12));
let ps = p1; // move!
println!("p2: {:?}", p2);
println!("p1: {:?}", p1); // 所有権をムーブしたためアクセス不可

p1 = Parent(2, Child(21), Child(22));
println!("p1: {:?}", p1);
```

所有権のムーブを伴う操作は以下の通り。

- パターンマッチ（macth 式でも let 文でも）
- 関数呼び出し
- 関数やブロックからのリターン
- コンストラクタ
- move クロージャ

## コピーセマンティクス

構造体や列挙型に Copy トレイト（ `std::marker::Copy` ）を実装すると、値がコピーされるようになる（≠ ムーブ）。

```
#[derive(Copy, Clone, Debug)]
struct Parent(usize, Child, Child);

#[derive(Copy, Clone, Debug)]
struct Child(usize);
```

`let p2 = p1` という同じシンタックスが、コピーセマンティクスに変わる。

```
let mut p1 = Parent(1, Child(11), Child(12));
let ps = p1; // copy!
println!("p2: {:?}", p2);
println!("p1: {:?}", p1); // p1 は元の値を所有するため、問題なくアクセスできる
```

### Copy トレイトを実装する主な型

- すべてのスカラ型
- 不変の参照 `&T` 型、生ポインタ `*const T` 型と `*mut T`型
- 関数ポインタ型と関数定義型
- すべての要素に Copy を実装した型を持つタプル型と配列型
- 環境に何も捕捉しない、または、Copy を実装した型だけを捕捉したクロージャ型
- すべての要素が Copy を実装した型を持つ `Option<T>` 型と `Result<T, E>` 型
- `std::cmp::Ordering` 、 `std::net::IpAddr` 、 `std::marker::PhantomData<T>` 型、など

標準ライブラリで Copy トレイトを実装した型の一覧は、API ドキュメントの `std::marker::Copy` のページにある。

- https://docs.w3cub.com/rust/std/marker/trait.copy/

### Copy トレイトと Clone トレイトの違い

| トレイト | コピーの実行                                 | コピーの処理内容                                         | コピーの実行時コスト |
| -------- | -------------------------------------------- | -------------------------------------------------------- | -------------------- |
| Copy     | 暗黙的。所有権がムーブする場面でコピーされる | 単純なバイトレベルのコピー。ロジックのカスタマイズは不可 | 低い                 |
| Clone    | 明示的。clone メソッドによりコピーされる     | シンプルなロジックから複雑なロジックまで自由に実装できる | 実装次第             |

自分の型を定義した際に Copy トレイトを実装できる要件が揃っているなら、一般的には Copy を実装することが望ましい。
ただ、後から取りやめるのは難しいため、十分に検討してから実装すること。

## 借用

所有権をムーブしてほしくない場合は参照を使う。

```
fn f1(p: &Parent) {
    println!("p: {:?}", p);
}

fn f2(p: &mut Parent) {
    p.0 *= -1;
}

let mut p1 = Parent(1, Child(11), Child(12));
f1(&p1);
fn(&mut p1);
println!("p1: {:?}", p1);
```

## 参照のライフタイムと借用規則

借用規則が守られているかはコンパイラの借用チェッカ（borrow checker）によって検査される。
Rust コンパイラには二種類の借用チェッカの実装がある。

- 従来の借用チェッカ：レキシカルスコープに基づくライフタイムの推論を行う
- 新しい借用チェッカ：制御フローグラフに基づくライフタイムの推論を行う。通称 NLL（Non-Lexical Lifetime）

NLL は Rust 1.31.0 から導入されている。
このバージョンでは、NLL は 2018 Edition を選んだときだけ有効になる。

## ライフタイムの詳細

### ライフタイムの省略

関数の引数と戻り値に参照が現れるとき、それらの関係を示すためにライフタイム指定子を付けられる。

```
pub fn get_or<'a>(&'a self, index: usize, default: &'a T) -> 'a T {
    self.get(index).unwrap_or(default)
}
```

ライフタイムの省略に関する規則は以下の通り。

- 関数の戻り値が参照型のとき、ライフタイムを省略できる
- 引数の中で参照型が 1 つだけなら、その引数から借用する
- 第一引数が `&self` または `&mut self` のメソッドなら、self から借用する
- それ以外の場合はライフタイムは省略できず、コンパイルエラーになる

ライフタイムは where 節を使って指定することもできる。

```
pub fn get_or<'a, 'b>(&'a self, index: usize, default: &'b T) -> 'a T {
where
    'b: 'a // 'b は 'a よりも長く生存する、の意
{
    self.get(index).unwrap_or(default)
}
```

### 'static ライフタイム

'static ライフタイムは、プログラムの終了時まで続き、他のどのライフタイムよりも長く生存する。
'static ライフタイムが持つ参照は、基本的に static 変数の値、または、リテラルなどのコンパイル時に値が確定するものからしか作れない。

例えば、スレッドを起動する関数（ `std::thread::spawn` ）などで使用する。
（引数に 'static スコープを持つクロージャをとる。）

## 共同所有者を実現するポインタ

`Rc<T>` を使うことで、リソースに対して複数の所有者を持たせることができる。
（Rc は Reference Counted の略。）

- `Rc::new(対象のリソース)` で新しい Rc ポインタを作る。対象のリソースはヒープ領域に格納される
- `Rc::clone` すると新しい所有者を追加できる。参照カウントが 1 つ増える
- Rc ポインタがスコープを抜けると参照カウントが 1 つ減る
- 参照カウントが 0 になったとき、リソースが解放される

複数スレッドで値を共有したい場合は `Arc<T>` を使う。
（Arc は Atomically Reference Counted の略。）
Rc は複数スレッドでの共有はできないが、Arc と比較して処理速度上のオーバヘッドが少ないというメリットがある。

対象のリソースを `Rc::new` 関連関数に与えることで Rc ポインタが作れる。

共同所有者を追加したいときは `Rc::clone` 関連関数でポインタを複製する。
このとき参照カウントが 1 つ増える。

`Rc::get_mut` 関連関数は参照カウントが 1 のときは Some を返す。
（それ以外の場合は None を返す。）
こうして得られた可変の参照を通じてリソースを変更できる。

`Rc::downgrade` 関連関数は Weak ポインタを返す。
参照カウント（strong_count）とは別に weak_count が 1 つ増える。

Weak ポインタからリソースにアクセスする際は `upgrade` メソッドで Rc ポインタに昇格させる。
リソースが存在するなら Some を返し、解放済みなら None を返す。

## 内側のミュータビリティ

内側のミュータビリティとは、コンパイル時の借用チェックを迂回してデータを可変にする仕組みのこと。
不変の参照経由でアクセスしたフィールドを変更することができる。

```
use std::cell::RefCell;

struct B {
    c: char,
    s: RefCell<String>,
}

let b = B { c: 'a', s: RefCell::new("alex",to_string()) };
let rb = &b;
rb.s.borrow_mut().push('a');
```

`RefCell` の `borrow_mut` などを使うことで、データへの可変の参照を返すことができる。
`borrow` メソッドを使えば不変の参照も作れる。

RefCell は実行時に貸し出しの数をカウントして借用規則にしたがっているかをチェックする。
他の参照が有効な時に `borrow_mut` を呼ぶと panic する。
`try_borrow_mut` は Result 型の値を返す（借用できない場合は Err を返す）。

シングルスレッドの場合は `RefCell` または `Cell` で実現できる。
マルチスレッドの場合は `Mutex` 、 `RwLock` などで実現できる（AtomicI32 などもマルチスレッド向け）。

## クロージャと所有権

クロージャは関数と環境に捕捉した変数からなるデータ構造。
クロージャが実装するトレイトには Fn、FnMut、FnOnce がある。

- Fn：クロージャが不変の環境を持つ
- FnMut：クロージャが可変の環境を持つ。所有権はムーブしない
- FnOnce：環境からクロージャの本体へ所有権をムーブする。一回だけ実行可能

```
fn apply_fn<F>(f: &F, ch: char) where F: Fn(char) -> bool {
    assert!(f(ch));
}

fn apply_fn_mut<F>(f: &mut F, ch: char) where F: FnMut(char) -> bool {
    assert!(f(ch));
}

fn apply_fn_once<F>(f: F, ch: char) where F: FnOnce(char) -> bool {
    assert!(f(ch));
}
```

関数に定義したクロージャはこんな感じで呼び出す：

```
let s1 = "read-only";
let mut lookup = |ch| s1.find(ch).is_some();

apply_fn(&lookup, 'r');
apply_fn_mut(&mut lookup, 'o');
apply_fn_once(lookup, 'y');
```

---

# トレイトとポリモーフィズム

---

## トレイトの基本

### 基本的な使い方

トレイトは型に対して実装すべきメソッドを定義したもの。
（厳密には違うけれど、Java でいう interface 的なやつ。）

トレイトを定義する：

```
trait Coordinates {
    fn to_cartesian(self) -> CartesianCoord;
    fn from_cartesian(cart: CartesianCoord) -> Self;
}
```

トレイトを構造体に実装する：

```
struct CartesianCoord {
    x: f64,
    y: f64,
}

impl Coordinates for CartesianCoord {
    fn to_cartesian(self) -> CartesianCoord {
        self
    }

    fn from_cartesian(cart: CartesianCoord) -> Self {
        cart
    }
}
```

### トレイト境界

ジェネリクスで受け取る型に境界を持たせることができる。
（具体的な型名に言及せずに「引数は xx トレイトを実装した何らかの型である」と抽象化できる）

ジェネリクスの型パラメータに `: トレイト名` を指定するやり方。

```
fn print_point<P: Coordinates>(point: P) {
    let p = point.to_cartesian();
    println!("{}, {}", p.x, p.y);
}
```

関数の型の後に `where トレイト境界` を指定するやり方。

```
fn print_point<P>(point: P)
where
    P: Coordinates,
{
    let p = point.to_cartesian();
    println!("{}, {}", p.x, p.y);
}
```

impl Trait 構文を使う、というやり方もある。

```
fn print_point(point: Impl Coordinates) {
    let p = point.to_cartesian();
    println!("{}, {}", p.x, p.y);
}
```

１つの型に複数のトレイト境界をつけることもできる。
その際は `+` で複数の境界を区切る。

### トレイトの継承

`トレイト名: 継承するトレイト名` とすることでトレイトの継承ができる。
このトレイトを実装する時は、継承するすべてのトレイトを実装してからでないと目的のトレイトの実装を書けない。

トレイト定義：

```
trait LinearTransform: Coordinates {
    fn transform(self, matrix: &Matrix) -> Self;
}
```

トレイトの実装：

```
impl LinearTransform  for CartesianCoord {
    fn transform(mut self, matrix: &Matrix) -> Self {
        let x = self.x;
        let y = self.y;
        let m = matrix.0;

        self.x = m[0][0] * x + m[0][1] * y;
        self.y = m[1][0] * x + m[1][1] * y;
        self
    }
}
```

### デフォルト実装

トレイトのメソッドはデフォルト実装を持つことができる。
（Java でいうと interface にデフォルト実装が定義できる、的なイメージ。）

```
trait LinearTransform: Coordinates {
    fn transform(self, matrix: &Matrix) -> Self;

    fn rotate(self, theta: f64) -> Self
    where
        Self: Sized,
    {
        self.transform(&Matrix([
            [theta.cos(), -theta.sin()],
            [theta.sin(), theta.cos()],
        ]))
    }
}
```

### トレイトとスコープ

トレイトで定義した関数は、トレイトとそれを実装する型が可視であれば他のモジュールからアクセスできる。
関数ごとに pub をつける必要はない。

トレイトのメソッドを利用するには、トレイトがスコープにいる必要がある。

```
use crate::some_module::Cordinates;
let p = (1.0, 0.0).to_cartesian();
```

### トレイト実装のルール

あるトレイト trait をある型 Type に実装するためには、トレイトまたは型の少なくともどちらか一方の定義のあるクレートで実装しなければならない。というルールがある。
Rust ではこれを孤児規則（orphan rule）と呼んでいる。

- https://qnighy.hatenablog.com/entry/2017/07/20/220000

### 自動導出

いくつかの標準ライブラリのトレイトは `#[derive(xxx)]` を使うことで、型定義時に自動で実装が導出される。

```
#[derive(Debug, Clone)]
pub struct CartesianCoord {
    pub x: f64,
    pub y: f64,
}
```

標準ライブラリで導出可能なのは Clone、Copy、Debug、Default、Eq、Hash、Ord、PartialEq、PartiaOrd。
これらの derive は可能な限りつけるのが良い、とされている。

## トレイトのジェネリクス

トレイトにも `trait トレイト名<型パラメータ名>` でジェネリクスを宣言できる。

```
trait Init<T> {
    fn init(t: T) -> Self;
}
```

## 静的ディスパッチと動的ディスパッチ

Rust では、ジェネリクスは静的ディスパッチにより実現されている。
そのため、ジェネリクス関数は普通の関数と変わらない速度で動作する。

動的ディスパッチは、実行時にわかる情報からコードを使い分ける方式。
Rust ではトレイトオブジェクトで実現されている。

トレイトオブジェクトは同じトレイトを実装している複数の型を統一的に扱える仕組み。
`dyn Trait` という記法でトレイトオブジェクトの型を表すことができる。

```
use std::fmt::Display;

let mut v: Vec<&dyn Display> = vec![];
v.push(&true);
v.push(&1i32);
```

## 存在 impl Trait

引数の位置に定義する impl は、全称 impl Trait と呼ばれる。
戻り値に定義する impl は存在 impl Trait と呼ばれる。

```
fn to_n(n: i32) -> impl Iterator {
    0..n
}
```

こうすると、具体的な型名に言及せずに「戻り値は xx トレイトを実装した何らかの型である」と抽象化できる。

## トレイトとアイテム

### 関連関数

構造体などと同様、トレイトにも関連関数を持たせることができる。

```
pub trait Coodinates {
    fn from_cartesian(cart: CartesianCoord) -> Self;
}
```

`型名::関数名` で呼び出せる。

```
let c = CartesianCoord {
    x: 1.0.
    y: 0.0,
};
let p = PolarCoord::from_cartesian(c);
```

型が推論可能であれば、 `トレイト名::関数名` でも呼び出せる。

```
let p: PolarCoord = Coordinates::from_cartesian(c);
```

### 関連定数

定数をトレイトに関連づけることもできる。

トレイトの定義：

```
trait Dimension {
    const DIMENSION: u32;
}
```

トレイトの実装：

```
impl Dimension for CartesianCoord {
    const DIMENSION: u32 = 2;
}
```

### 関連型

トレイトに関連づいた型を定義することができる。
`trait トレイト名 { type 関連型名 [: トレイト制約] }` で関連型を定義できる。

トレイト定義：

```
use std::str::FromStr;

trait Server {
    type Response;
    type Request: FromStr;

    fn handle(&self, req: Self::Request) -> Self::Response;
}
```

トレイトの実装：

```
struct EchoServer;

impl Server for EchoServer {
    type Response = String;
    type Request = String;

    fn handle() -> Self::Respose {
        req
    }
}
```

こんな感じで、request と response にどの型を使うべきかを実装させることができる。

---

# パッケージを作る

---

## ドキュメントを書く

### ドキュメントの書式

ドキュメントにはマークダウンを書ける。
規約としていくつかのセクション名が特定の説明に対して用いられる。

- Panics：関数がパニックを起こす可能性がある場合に、その条件を書く
- Errors：関数が Result を返す場合に、エラーを返す条件を書く
- Safety：unsafe な関数を書く時にユーザが保証すべき条件を書く
- Examples：関数の使い方の例を書く

ドキュメント内のコードブロックはテスト時に同時にコンパイルされ、実行される。
これにより、正しくないコード例が残ってしまい、ドキュメントが陳腐化することを防げる。

### ドキュメント文章の記載

ドキュメントの書き忘れ防止のために `missing_docs` の Lint が用意されている。
main.rs の先頭に `#![warn(missing_docs)]` をつけると、コンパイル時に警告を出してくれる。

ドキュメントのビルドは cargo コマンドで行える。

```
cargo doc
```

## テストの追加

テスト用の関数に `#[test]` アトリビュートをつけるとテストとして機能する。

```
#[test]
fn word_count_works() {
    use std::io::Cursor;

    let mut exp = HashMap::new();
    exp.insert("aa".to_string(), 1);
    exp.insert("bb".to_string(), 2);
    exp.insert("cc".to_string(), 1);

    assert_eq!(count(Cursor::new("aa bb cc dd"), CountOption::Word), exp);
}
```

### さまざまなテストを書く

std には値の比較用のマクロがいくつか定義されている。

- `assert!(expr)` ：expr が true を返すかを調べる
- `assert_eq!(left, right)` ：左右が等しいかを調べる（PartialEq が必要）
- `assert_neq!(left, right)` ：左右が等しくないかを調べる（PartialEq が必要）

テスト関数には `()` でなく Result を返すこともできる。
戻り値を Result にすることでテスト内で `?` 演算子を使えるようになる。

```
use std::io;

#[test]
fn result_test() -> io::Result<()> {
    use std::fs::{read_to_string, remove_file, write};

    write("test.txt", "message")?;
    let message = read_to_string("test.txt")?;
    remove_file("test.txt")?;

    assert_eq!(message, "message");
    Ok(())
}
```

パニックすることを確認するためのテストも書くことができる。
テスト関数に `#[should_panic]` アトリビュートをつけることで実現できる。

```
#[test]
#[should_panic]
fn word_count_do_not_contain_unknown_words() {
    use std::io::Cursor;

    count(
        Cursor::new([
            b'a',
            0xf0, 0x90, 0x80,
            0xe3, 0x81, 0x82,
        ]),
        CountOption::Word,
    );
}
```

### テストを書く場所

アイテムに `#[cfg(test)]` アトリビュートをつけると、テストモードでのみそのアイテムがコンパイルされるようになる。
これを利用することで、テスト用のコードが通常の成果物にコンパイルされることなくテストを書ける。

test 直下にテストをかくと、Cargo がそれらをテストクレートとしてコンパイルしてくれる。
test 対象のモジュールとは別のクレートして扱われるため、インポートが必要になる。

また、ドキュメント中に書いたコードブロックもテストされる。

## パッケージを公開するために

以下のコマンドでパッケージがビルドできる。

```
cargo build
```

リリース向けのビルドを作る時は `--release` フラグをつける。

```
cargo build --release
```

リリース向けのビルドは `taget/release` ディレクトリに出力される。
`build` のほか、 `run` や `test` なども `--release` フラグをつけることができる。

---

# Web アプリケーション、データベース接続

---

## Rust と Web の現状

### Futures と Tokio

Rust でネットワークを非同期に扱おうとすると、Futures と Tokio のライブラリが関わってくる。

Futures は並行デザインパターンの Future を Rust 上に実装したもの。
（同じものを Promise と呼ぶ言語もある。）
時間のかかる処理の完了を待たずに別の処理を先に進め、後から元の処理の結果を受け取る、みたいなパターンで使う。

Tokio はイベント駆動なネットワークの非同期 IO やタスクの非同期実行などを Futures を使ってラップしたもの。
基本的な非同期 IO やスケジューリング、タイマーなどの機能を Tokio で提供。
ネットワークアプリケーションのフレームワーク部分は Tower が提供している。

### Rust での非同期の未来

- Rust で非同期 IO を扱うには Tokio と Futures を使う
- Futures のための構文が Rust 本体に入る予定だが時期は未定
- Futures は Rust 本体に取り込まれる予定だが時期は未定
- Futures が Rust 本体に取り込まれる際に API が変わる
  - （1.39 で async/await 構文がサポートされたようだ）
  - https://www.infoq.com/news/2019/11/rust-async-await/

### Web アプリケーションフレームワーク

Rust の Web アプリケーションフレームワークいろいろ：

- Iron：https://github.com/iron/iron
- Rocket：https://github.com/SergioBenitez/Rocket
- Gotham：https://github.com/gotham-rs/gotham
- Tower Web：https://github.com/carllerche/tower-web
- Warp：https://github.com/seanmonstar/warp
- Tide：https://github.com/http-rs/tide
- Actix Web：https://github.com/actix/actix-web

2018 年後半の時点では Rocket と Actix Web がよく使われているらしい。

## Web アプリケーションフレームワーク Actix Web

アクターとは非同期にメッセージをやりとりする存在。
アクター同士はメッセージでしか相互作用にないので、独立性が高い。
アクターをベースにアプリケーションを構築すると IO やエラーを分離したり、容易にマルチコアで動かせたりなどのメリットがある。

### Hello, Actix Web

```
use actix_web::{server, App, HttpRequest, Responder};

fn hello(req: &HttpRequest) -> impl Responder {
    let to = req.match_info().get("name").unwrap_or("Workd");
    format!("Hello {}!", to);
}

fn main() {
    server::new(|| {
        App::new()
            .resource("/", |r| r.f(hello))
            .resource("/{name}", |r| r.f(hello))
    })
    .bind("localhost:3000")
    .expect("Can not bind to port 3000")
    .run();
}
```

### Actix Web とサーバの構成要素

- HttpServer：HTTP を処理するサーバ。コネクションや SSL、ワーカ数などを設定したい場合はこの型を使う
- App：アプリケーションデータの保持やリクエストのルーティングを担当
- ハンドラ：実際にリクエストを処理する中身
- エクストラクタ：HTTP リクエストからデータを抽出する。重要なエクストラクタに State がある
- ミドルウェア：リクエストを処理する前後に何かしらの処理をする。リクエストログを取ったり、セッション管理をしたりするなどさまざまなミドルウェアが用意されている

serde_derive は serde が提供する変換用トレイトのカスタム自動導出を提供するライブラリ。
いわゆる Serialize と Deserialize ができる。

### テンプレートを返す。

jinja2 にインスパイアされた Tera というテンプレートエンジンがあるようだ。
（Spring でいうところの Thymeleaf 的なやつかな。）

## JSON API サーバ

サーバとクライアントなど、複数のクレートをまとめて取り扱う場合はワークスペース機能が便利。
ワークスペースを使うことで以下のような恩恵を受けられる。

- 依存クレートのコンパイルの共通化ができる
- ワークスペース内の依存関係を考慮したビルドができる
- 配下のクレートすべてのテストをビルドすることもできる

トップレベルの Cargo.toml にワークスペース宣言を書くことで有効になる。

```
[workspace]
members = ["server", "cli", "api"]
```

アプリケーションのログを取るためのクレートとしては、log と env_logger などがある。
エラーハンドリングのクレートとしては failure がある。
（Actix Web が内部で使用しているため、一緒に使うことになる。）

日時を扱うクレートとしては chrono がデファクト。

## Diesel を使ったデータベースの扱い

Disel は Rust のための安全で拡張可能な ORM かつクエリビルダ。

- CLI ツールから DB のスキーマを読みに行って Rust のコードを生成
- ユーザは生成された DSL を使ってクエリを組み立て
- Diesel が DB のスキーマに合わせたコードを生成するので DSL にはスキーマに対応した型がつく
- 不正な SQL を書いてしまう余地が少なく、 SQL のデバッグをしなくて済む。パフォーマンスにも優れた作りになる

### diesel_cli のインストール

cargo から diesel_cli をインストールすることで CLI ツールが使えるようになる。

```
cargo install diesel_cli
```

### スキーマ定義とマイグレーション

接続先を指定して setup コマンドを実行すると、データベースが作成され、migrations ディレクトリができる。

```
diesel setup
```

マイグレーションファイルの雛形を作る時は `diesel migration` コマンド。

```
diesel migration generate MIGRATION_NAME
```

up.sql にDB への変更を、down.sql に変更を取り消す処理を記述する。
マイグレーションを走らせると、 schema.rs にテーブルスキーマに対応する Rust のコードが生成される。
（Rails っぽい。）

```
diesel migration run
```

### モデルの定義

テーブルに対応する model を作成する。

```
use crate::schema::*;
use chrono::NaiveDateTime;

#[derive(Debug, Clone, Eq, PartialEq, Hash, Insertable)]
#[table_name = "logs"]
pub struct NewLog {
    pub user_agent: String,
    pub response_time: i32,
    pub timestamp: NaiveDateTime,
}
```

Diesel 経由でデータベースに書き込みをしたい場合、 Insertable の導出が必要。
データベースから SELECT した結果をマップするには Queryable の導出が必要。

---

## CLI クライアントの作成

コマンドラインのパーサとしては Clap が便利。

API を同期通信で扱うには `Reqwest` が便利。