### std::thread

- The threading model

実行中のRustプログラムは、ネイティブOSのスレッドのコレクションで構成されており、それぞれが独自のスタックとローカルステートを持っている。

スレッドは名前を付けることができ、低レベルの同期のためのいくつかの組み込みサポートを提供している。
スレッド間の通信は、チャンネル、Rust のメッセージ通過型、他の形式のスレッド同期、共有メモリデータ構造を介して行うことができる。特に、スレッドセーフであることが保証されている型は、原子的に参照カウントされたコンテナ`Arc`を使用してスレッド間で簡単に共有することができる。

Rust で致命的なロジックエラーが発生すると、スレッドパニックが発生し、その間にスレッドはスタックを巻き戻し、デストラクタを実行し、所有するリソースを解放します。これは、スレッドがスタックを巻き戻し、デストラクタを実行し、所有するリソースを解放することを意味する。パニックが捕捉されなかった場合、スレッドは終了しますが、オプションで`join`を使用して別のスレッドからパニックを検出することができる。パニックが捕捉されずにメインスレッドがパニックに陥った場合、アプリケーションは0以外の終了コードで終了します。
      Rust プログラムのメインスレッドが終了すると、他のスレッドが実行中であってもプログラム全体がシャットダウンします。しかし、このモジュールは自動的に子スレッドの終了を待つための便利な機能を提供している。
      
- Spawning a thread

新しいスレッドは`thread::spawn`関数を使って生成することができる。
    
```rust
use std::thread;

let child = thread::spawn(move || {
// some work here
});
// some work here
let res = child.join();
```

`join`メソッドは、子スレッドが生成した最終的な値の`Ok`を含む`thread::Result`を返し、子スレッドがパニックに陥った場合は`panic!`コールに与えられた値のErrを返す。

新しいスレッドを生成するスレッドと、生成されるスレッドの間には、親子関係はないことに注意してください。特に、生成されたスレッドは、産み出されたスレッドがメインスレッドでない限り、生成されたスレッドよりも長生きすることもあれば、しないこともあります。

- Configuring threads

新しいスレッドは、生成される前に`Builder`タイプで設定することができ、現在はスレッドの名前とスタックサイズを設定することができます。

```rust
use std::thread;

thread::Builder::new().name("thread1".to_string()).spawn(move || {
    println!("Hello, world!");
});
```

- The Thread type
    

スレッドは、2 つの方法のいずれかで取得できる `Thread`型を介して表現される。
    

1. `thread::current`関数を使用して、現在のスレッドを要求する。

2. `thread::current`関数は、このモジュールの`API`によってスポーンされないスレッドに対しても利用可能。

- Thread-local storage

このモジュールは、`Rust`プログラム用のスレッドローカルストレージの実装も提供する。スレッドローカルストレージは、プログラム内の各スレッドが独自のコピーを持つグローバル変数にデータを格納する方法。スレッドはこのデータを共有しないので、アクセスを同期させる必要はない。スレッドローカルキーは、それが含む値を所有し、スレッドが終了したときにその値を破棄します。thread_local! マクロで作成され、`'static`(借用ポインタはない)な値を含むことができる。これは、指定されたクロージャへの値への共有参照を生成するアクセサ関数`with`を提供します。スレッドローカルキーは、値への共有アクセスのみを許可している。ほとんどの値は、`Cell`型や`RefCell`型を用いて何らかの形式の内部変異性を利用したいと考えるであろう。


- Naming threads

スレッドは、識別のために関連付けられた名前を持つことができる。デフォルトでは、スポーンされたスレッドには名前が付けられていない。スレッドの名前を指定するには、`Builder`でスレッドをビルドし、希望するスレッド名を`Builder::name`に渡します。スレッド名をスレッド内から取得するには Thread::name を使用します。スレッド名が使用される例をいくつか挙げます。

1. 指定されたスレッドでパニックが発生した場合、そのスレッド名がパニックメッセージに表示される。

2. スレッド名は、該当する場合には OS に提供される (例: unix ライクなプラットフォームでは `pthread_setname_np`)。

- Stack size

スポーンされるスレッドのデフォルトのスタックサイズは 2 MiB ですが、この特定のスタックサイズは将来的に変更される可能性がある。スポーンされるスレッドのスタックサイズを手動で指定するには、2つの方法がある。

1. Builder でスレッドをビルドし、希望するスタックサイズを`Builder::stack_size`に渡す。

2. 環境変数`RUST_MIN_STACK`を、希望するスタックサイズを表す整数 (バイト単位)に設定する。`Builder::stack_size`の設定はこれをオーバーライドすることに注意。

メインスレッドのスタックサイズはRustによって決定されないことに注意。

---

#### std::thread::spawn

- Description

  新しいスレッドを生成し、そのための`JoinHandle`を返します。

  `JoinHandle`は、ドロップされると暗黙のうちに子スレッドを切り離します。この場合、子スレッドは親スレッドよりも長生きする可能性があります（親スレッドがメインスレッドの場合は別ですが、メインスレッドが終了するとプロセス全体が終了します）。さらに、`JoinHandle`は、子スレッドに参加するために使用できる`join`メソッドを提供します。子スレッドがパニックに陥った場合、`join`は`panic！`に与えられた引数を含む`Err`を返します。

  スタックサイズやスレッドの名前を指定したい場合は、代わりにこのAPIを使用してください。

  spawnのシグネチャを見るとわかるように、spawnに与えられるクロージャとその戻り値の両方に2つの制約があります。

  - `'static`制約とは、クロージャとその戻り値は、プログラムの実行全体の寿命を持たなければならないということです。その理由は、スレッドが切り離され、作成されたライフタイムよりも長くなることがあるからです。実際、スレッドとその戻り値が呼び出し元よりも長くなる可能性がある場合、その後も有効であることを確認する必要があります。また、いつ戻り値が返されるかわからないので、できるだけ長く、つまりプログラムの終わりまで有効である必要があり、それが「静的寿命」の理由です。
  - `Send`制約は、クロージャが生成されたスレッドから新しいスレッドに値を渡す必要があるからです。クロージャの戻り値は、新しいスレッドからそれが結合されたスレッドに渡される必要があります。覚えておいていただきたいのですが、`Send`マーカートレイトはスレッドからスレッドに渡されても安全であることを表現しています。Sync は、スレッドからスレッドへ参照を渡すことが安全であることを表現しています。

- Panics

  このようなエラーから回復するには`Builder::spawn`を使用してください。

- Example

  Creating a thread.

```rust
  use std::thread;
  
  let handler = thread::spawn(|| {
      // thread code
  });
  
  handler.join().unwrap();
```

  モジュールのドキュメントにあるように、スレッドは通常[チャンネル](https://doc.rust-lang.org/stable/std/sync/mpsc/index.html)を使って通信するようになっており、以下のようになっています。

  この例では、値の所有権をスレッドに与えるために、`move`を使用する方法も示しています。

```rust
  use std::thread;
  use std::sync::mpsc::channel;
  
  let (tx, rx) = channel();
  
  let sender = thread::spawn(move || {
      tx.send("Hello, thread".to_owned())
          .expect("Unable to send on channel");
  });
  
  let receiver = thread::spawn(move || {
      let value = rx.recv().expect("Unable to receive from channel");
      println!("{}", value);
  });
  
  sender.join().expect("The sender thread has panicked");
  receiver.join().expect("The receiver thread has panicked");
```

  スレッドは[`JoinHandle`](https://doc.rust-lang.org/stable/std/thread/struct.JoinHandle.html)を通じて値を返すこともでき、これを使って非同期の計算を行うことができます（futuresの方がより適切かもしれません）。



---

#### [std](https://doc.rust-lang.org/stable/std/index.html)::[thread](https://doc.rust-lang.org/stable/std/thread/index.html)::JoinHandle

- Description

  スレッドに参加するために所有されているパーミッション(終了時にブロック)。

  `JoinHandle`は、関連するスレッドが削除されたときに関連するスレッドを切り離します。

  プラットフォームの制限のため、このハンドルを複製することはできません: スレッドに参加する能力は、一意に所有する権限です。

  この構造体は `thread::spawn`関数と`thread::Builder::spawn`メソッドによって作成されます。

---

#### std::thread::JoinHandle::join

  - Description

    関連するスレッドの終了を待つ。
    アトミックメモリの順序付けの観点からは、関連付けられたスレッドの完了は、この関数のリターンと同期する。
    言い換えれば、そのスレッドによって実行されたすべての操作は、joinが戻ってきた後に発生するすべての操作よりも先に順序付けられる。
    子スレッドがパニックに陥った場合、`panic！`に与えられたパラメータで`Err`が返される。
    この関数は、プラットフォームによってはスレッドが自分自身に参加しようとした場合にパニックを起こすかもしれないし、そうでなければスレッドの`join`でデッドロックを起こすかもしれない。

---

#### std::thread::sleep

  - Description

    現在のスレッドを、少なくとも指定した時間だけスリープ状態にする。
    スレッドは、スケジューリングの仕様やプラットフォーム依存の機能のために、指定された時間よりも長くスリープすることがある。スレッドのスリープ時間が短くなることはない。
    この関数はブロッキングであり、非同期関数では使用すべきではない。

---

#### std::thread::LocalKey

- Description

  そのコンテンツを所有するスレッドローカルストレージキー。

  このキーは、ターゲットプラットフォームで利用可能な最速の実装を使用します。このキーは[`thread_local!`](https://doc.rust-lang.org/std/macro.thread_local.html)マクロでインスタンス化され、主なメソッドは [with](https://doc.rust-lang.org/std/thread/struct.LocalKey.html#method.with)メソッドです。

  `with`メソッドは、含まれる値への参照を生成します。この参照は、スレッド間で送信したり、与えられたクロージャから抜け出すことはできません。

- Initialization and Destruction

  初期化は、スレッド内で`with`を最初に呼び出したときに動的に実行され、`Drop`を実装した値は、スレッドが終了するときに破棄されます。いくつかの注意点がありますので、以下に説明します。

  `LocalKey`のイニシャライザは、自分自身に再帰的に依存することはできません。この方法で`LocalKey`を使用すると、イニシャライザは`with`の最初の呼び出しで無限に再帰することになります。

- Example

```rust
  use std::cell::RefCell;
  use std::thread;
  
  thread_local!(static FOO: RefCell<u32> = RefCell::new(1));
  
  FOO.with(|f| {
      assert_eq!(*f.borrow(), 1);
      *f.borrow_mut() = 2;
  });
  
  // each thread starts out with the initial value of 1
  let t = thread::spawn(move|| {
      FOO.with(|f| {
          assert_eq!(*f.borrow(), 1);
          *f.borrow_mut() = 3;
      });
  });
  
  // wait for the thread to complete and bail out on panic
  t.join().unwrap();
  
  // we retain our original value of 2 despite the child thread
  FOO.with(|f| {
      assert_eq!(*f.borrow(), 2);
  });
```

- Platform-specific behavior

  スレッドローカルストレージに格納されている型のデストラクタが実行されるように「最善の努力」が払われていますが、すべてのプラットフォームでスレッドローカルストレージのすべての型に対してデストラクタが実行されることが保証されているわけではないことに注意してください。例えば、デストラクタが実行されない既知の注意点がいくつかあります。

  1. Unixシステムで`pthread`ベースの TLS が使用されている場合、メイン・スレッドが終了する際に TLS の値に対してデストラクタが実行されません。メイン・スレッドが終了した直後に、アプリケーションも終了することに注意してください。
  2. すべてのプラットフォームで、TLSが破壊時に他のTLSスロットを再初期化することが可能です。一部のプラットフォームでは、破壊されたスロットの再初期化を防止することで、この現象が無限に起こらないようにしていますが、すべてのプラットフォームがこのガードを持っているわけではありません。ガードをしないプラットフォームでは、通常、合成制限を設けており、それを超えるとデストラクタは実行されません。



---

#### std::thread::LocalKey::with

- Description

  TLS キーの値への参照を取得します。

  このスレッドがまだこのキーを参照していない場合は、遅延的に値を初期化します。

- panics

  この関数は、キーに現在デストラクタが実行されている場合には`panic!()`し、以前にこのスレッドでデストラクタが実行されていた場合には`panic`することがあります。

