### Crate zerocpy

- Description

  安全なゼロコピー解析とシリアル化のためのユーティリティ。

  このクレートは、バイト スライスとの間のゼロ コピー変換を可能にすることで、ゼロ コピー パージングおよびシリアライズを簡単に実行できるユーティリティを提供します。

  この機能は、3つのコアマーカー特性によって実現されており、それぞれの特性は派生させることができます（例：`#[derive(FromBytes)]`）。

  - `FromBytes` は、ある型が任意のバイト列から安全に変換できることを示します。
  - `AsBytes`は、型がバイト列に安全に変換されることを示します。
  - `Unaligned`は、型のアラインメント要件が 1 であることを示します。
    これらの特性のサブセットを実装した型は、実行時のオーバーヘッドがほとんどない状態で、バイト列との間で変換することができます。

  これらの形質はバイトオーダーを無視していることに注意してください。バイト順を意識した型については、[`byteorder`](https://docs.rs/zerocopy/0.5.0/zerocopy/byteorder/index.html)モジュールを参照してください。

---

### zerocpy::FromBytes

- Description

  任意のバイトパターンが有効な型。

  警告: この特性を自分で実装しないでください! その代わり、`#[derive(FromBytes)]`を使用してください。

  `FromBytes`型は、信頼できないバイト列から安全にデシリアライズすることができます。なぜなら、どんなバイト列もこの型の有効なインスタンスに対応するからです。

  `FromBytes`型は、バイト順を意識しません。バイト順を考慮した型については、`byteorder`モジュールを参照してください。

- Safety

  `T: FromBytes`の場合、安全でないコードは、長さ`size_of::<T>()`の初期化されたバイト列をTとして扱うことが健全であると仮定することができます。この契約に違反する型が`FromBytes`としてマークされた場合、未定義の動作を引き起こす可能性があります。

  型が以下の特性を持っている場合、その型に対して`FromBytes`を実装することは安全です。

  - 型が構造体の場合。
    - その型のすべてのフィールドは、`FromBytes`を実装する必要があります
  - 型が列挙型の場合。
    - Cライクな列挙型であること（すべてのバリアントにフィールドがないこと）。
    - 定義された表現（`repr`s `C`, `u8`, `u16`, `u32`, `u64`, `usize`, `i8`, `i16`, `i32`, `i64`, or `isize`）を持たなければならない。
    - 最大数の識別記号を使用しなければなりません（可能なすべてのビットパターンが有効なものとなるように）。`C`、`usize`、`isize`の各表現を使用する場合は、そのサイズがプラットフォームに依存するため、十分に注意してください。

- Rationale

  Rustの[リファレンス](https://doc.rust-lang.org/nightly/std/primitive.reference.html)によると

  型の表現は、フィールド間のパディングを変更できますが、フィールド自体のレイアウトは変更できません。

  構造体のレイアウトは、パディングバイトとフィールドバイトのみで構成されているため、以下の場合、構造体は健全な`FromBytes`となります。

  1. 構造体のパディングが健全に`FromBytes`で、かつ
  2. 構造体のフィールドが適切に`FromBytes`である。

  パディングバイトには有効性の制約がないため、最初の質問に対する答えは常に「イエス」です。Unsafe Code Guidelines Working Groupで行われたこの問題に関する議論では、将来のバージョンの rustcがパディング・バイトに有効性の制約を加えることは事実上考えられないという結論に達しました。

  したがって、構造体が健全な`FromBytes`であるかどうかは、そのフィールドが`FromBytes`であるかどうかにのみ依存します。



---

### zerocpy::AsBytes

- Description

  不変のバイトスライスとして扱っても安全な型。

  警告: この特性を自分で実装しないでください! 代わりに、`#[derive(AsBytes)]`を使用してください。

  `AsBytes`型は、安全にバイトのスライスとみなすことができます。特に、この型の有効なインスタンスでは、そのインスタンスのどのバイトも初期化されていないことを意味します。これは次のような型を除外します。

  内部パディングのある構造体
  すべてのバリアントが同じ長さではないユニオン
  `AsBytes`はバイト順を意識しません。バイト順を考慮した型については、`byteorder`モジュールを参照してください。

- Custom Derive Errors

  `AsBytes`のカスタム導出の実装方法により、以下のようなエラーが発生する場合があります。

  ```
  error[E0080]: evaluation of constant value failed
    --> lib.rs:1:10
     |
   1 | #[derive(AsBytes)]
     |          ^^^^^^^ attempt to divide by zero
  ```

  このエラーは、アノテーションされている型にパディングバイトがあることを意味し、`AsBytes`型では違法です。パディングバイトがある場所に構造体のフィールドを明示的に追加するか、`#[repr(packed)]`を使用することを検討してください。

- Safety

  `T: AsBytes`の場合、安全でないコードは、その型のインスタンスを長さ `size_of::<T>()`の不変の `[u8]`として扱うことが健全であると仮定することができます。この契約に違反する型が`AsBytes`としてマークされた場合、未定義の動作を引き起こす可能性があります。

  型が以下のような特性を持っている場合、その型に`AsBytes`を実装しても安全です。

  - 型が構造体の場合。
    - 定義された表現（`repr(C)`, `repr(transparent`)、または`repr(packed)`)を持っていること。
    - すべてのフィールドが`AsBytes`でなければなりません。
    - レイアウトにパディングがないこと。これは`repr(transparent)`と`repr(packed)`では常に真です。`repr(C)`の場合は、[Rust Reference](https://doc.rust-lang.org/reference/type-layout.html)に記載されているレイアウトアルゴリズムを参照してください。
  - 型がenumの場合。
    - C-like enumでなければなりません (つまり、すべてのバリアントにはフィールドがありません)。
    - 定義された表現(`repr`s `C`, `u8`, `u16`, `u32`, `u64`, `usize`, `i8`, `i16`, `i32`, `i64`, or `isize`)でなければなりません。



